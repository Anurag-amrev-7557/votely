const axios = require('axios');

const API_URL = 'http://localhost:5001/api';
const ADMIN_EMAIL = 'anuragverma08002@gmail.com'; // Hardcoded admin email from authController
const STUDENT_EMAIL = 'student@iitbbs.ac.in';

async function verifyFullFlow() {
    console.log('üöÄ Starting Full Flow Verification...');

    try {
        // --- 1. AUTHENTICATION ---
        console.log('\nüîê 1. Testing Authentication...');

        // Register/Login Admin
        console.log(`   -> Auth Admin (${ADMIN_EMAIL})...`);
        let adminToken;
        try {
            const res = await axios.post(`${API_URL}/auth/register`, {
                name: 'Admin User',
                email: ADMIN_EMAIL,
                password: 'password123'
            });
            adminToken = res.data.token;
            console.log('      ‚úÖ Admin Registered');
        } catch (e) {
            if (e.response && e.response.status === 400 && e.response.data.error === 'User already exists') {
                const res = await axios.post(`${API_URL}/auth/login`, {
                    email: ADMIN_EMAIL,
                    password: 'password123'
                });
                adminToken = res.data.token;
                console.log('      ‚úÖ Admin Logged In');
            } else {
                throw e;
            }
        }

        // Register/Login Student
        console.log(`   -> Auth Student (${STUDENT_EMAIL})...`);
        let studentToken;
        try {
            const res = await axios.post(`${API_URL}/auth/register`, {
                name: 'Student User',
                email: STUDENT_EMAIL,
                password: 'password123'
            });
            studentToken = res.data.token;
            console.log('      ‚úÖ Student Registered');
        } catch (e) {
            if (e.response && e.response.status === 400 && e.response.data.error === 'User already exists') {
                const res = await axios.post(`${API_URL}/auth/login`, {
                    email: STUDENT_EMAIL,
                    password: 'password123'
                });
                studentToken = res.data.token;
                console.log('      ‚úÖ Student Logged In');
            } else {
                throw e;
            }
        }

        // --- 2. POLL CREATION ---
        console.log('\nüó≥Ô∏è  2. Testing Poll Creation...');
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        const dayAfter = new Date();
        dayAfter.setDate(dayAfter.getDate() + 2);

        const pollData = {
            title: `Student Council Election ${Date.now()}`,
            description: 'Election for the post of President',
            category: 'Election',
            startDate: new Date(Date.now() + 1000), // Active in 1 second
            endDate: dayAfter,
            options: [
                { text: 'Candidate A', description: 'Manifesto A', party: 'Party X' },
                { text: 'Candidate B', description: 'Manifesto B', party: 'Party Y' }
            ],
            settings: {
                allowMultipleVotes: false,
                showResultsAfterVote: true,
                requireAuthentication: true
            }
        };

        const pollRes = await axios.post(`${API_URL}/polls`, pollData, {
            headers: { Authorization: `Bearer ${adminToken}` }
        });
        const pollId = pollRes.data._id;
        console.log(`      ‚úÖ Poll Created! ID: ${pollId}`);
        console.log(`      Title: ${pollRes.data.title}`);


        // --- 3. VOTING ---
        console.log('\n‚úã 3. Testing Voting...');
        // Student votes for Candidate A (index 0) -- BUT wait, we need the option ID
        // The Poll model options don't usually have IDs generated by client, mongoose adds them.
        // Let's fetch the poll to get Option IDs.

        const fetchPollRes = await axios.get(`${API_URL}/polls/${pollId}`);
        const optionText = fetchPollRes.data.options[0].text;
        const optionId = fetchPollRes.data.options[0]._id; // Keep for reference if needed

        // Wait for poll to become active
        const START_DELAY_MS = 5000;
        console.log(`      ‚è≥ Waiting ${START_DELAY_MS}ms for poll to become ACTIVE...`);
        await new Promise(resolve => setTimeout(resolve, START_DELAY_MS));

        // Debug: Check poll status
        const debugPollRes = await axios.get(`${API_URL}/polls/${pollId}`);
        console.log(`      üëÄ Debug Poll Status: ${debugPollRes.data.status}`);
        console.log(`      üëÄ Debug Poll StartDate: ${debugPollRes.data.startDate}`);
        console.log(`      üëÄ Debug Server Now (approx): ${new Date().toISOString()}`);

        console.log(`   -> Voting for Option: ${optionText}`);

        const voteRes = await axios.post(`${API_URL}/votes/vote`, {
            pollId: pollId,
            options: [optionText]
        }, {
            headers: { Authorization: `Bearer ${studentToken}` }
        });

        if (voteRes.status === 200 || voteRes.status === 201) {
            console.log('      ‚úÖ Vote Cast Successfully');
        }

        // Verify Duplicate Vote Prevention
        console.log('   -> Attempting Duplicate Vote...');
        try {
            await axios.post(`${API_URL}/votes/vote`, {
                pollId: pollId,
                options: [optionText]
            }, {
                headers: { Authorization: `Bearer ${studentToken}` }
            });
            console.log('      ‚ùå ERROR: Duplicate vote was allowed!');
        } catch (e) {
            if (e.response && e.response.status === 400) {
                console.log('      ‚úÖ Duplicate Vote Blocked (Expected)');
            } else {
                console.log('      ‚ö†Ô∏è  Unexpected Error during duplicate vote:', e.message);
            }
        }

        // --- 4. RESULTS ---
        console.log('\nüìä 4. Testing Results...');
        const resultRes = await axios.get(`${API_URL}/polls/${pollId}`, {
            headers: { Authorization: `Bearer ${adminToken}` }
        });

        // Backend returns result with option text or ID? Poll model has options array.
        // Usually results are in resultRes.data.options

        // Find option by text
        const updatedOption = resultRes.data.options.find(o => o.text === optionText);

        // Results endpoint might return 'count' or 'votes' depending on implementation
        // getPollById includes voteCount if implemented there.
        // Let's check what verify-full-flow checks earlier: "updatedOption.votes"
        // In getPollById (pollController), it computes populates `voteCount`.
        // BUT poll schema has `votes` number on option? 
        // CastVote updates `votes` on option.

        // Controller: poll.options[idx].votes = ... + 1;
        // Controller: poll.options = ... map ... voteCount: ...

        const count = updatedOption.votes || updatedOption.voteCount || 0;

        if (count === 1) {
            console.log(`      ‚úÖ Vote Count Verified: 1`);
        } else {
            console.log(`      ‚ùå Vote Count Mismatch. Expected 1, got ${count}`);
            console.log('       Option data:', updatedOption);
        }

        console.log('\n‚ú® Full Verification Flow Completed Successfully! ‚ú®');
        // Output tokens for frontend testing
        console.log('\n--- TOKENS FOR FRONTEND TESTING ---');
        console.log('ADMIN_TOKEN:', adminToken);
        console.log('STUDENT_TOKEN:', studentToken);

    } catch (error) {
        console.error('\n‚ùå Verification Failed');
        if (error.response) {
            console.error('Status:', error.response.status);
            console.error('Data:', JSON.stringify(error.response.data, null, 2));
        } else {
            console.error('Error:', error.message);
        }
    }
}

verifyFullFlow();
